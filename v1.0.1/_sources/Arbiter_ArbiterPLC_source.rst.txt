

DUTs
----


GVLs
----


GVL
^^^

::

    VAR_GLOBAL
       {attribute 'pytmc' := '
        pv: @(PREFIX)Arbiter:01
        '}
        g_fbArbiter1	:	FB_Arbiter(25);

        ReqBP	:	ST_BeamParams; //Currently the placeholder for the fully arbitrated BP set

        //Example implementation of the FFO

        {attribute 'pytmc' := '
        pv: @(PREFIX)FFO:01
        '}
        {attribute 'TcLinkTo' := '.q_xFastFaultOut:=TIIB[FFO]^Channel 1^Output'}
        g_FastFaultOutput1	:	FB_HardwareFFOutput := (bAutoReset := TRUE);
    	
    	{attribute 'pytmc' := '
        pv: @(PREFIX)FFO:02
        '}
        {attribute 'TcLinkTo' := '.q_xFastFaultOut:=TIIB[FFO]^Channel 2^Output'}
        g_FastFaultOutput2	:	FB_HardwareFFOutput := (bAutoReset := TRUE);

        g_rTestingVelocity	:	LREAL := PMPS_GVL.VISIBLE_TEST_VELOCITY;

        AttemptReset    :   BOOL; // For testing
    END_VAR

    VAR_GLOBAL CONSTANT
    	MAX_FAST_FAULTS : UINT := 100;
    END_VAR


GVL_CheckBounds
^^^^^^^^^^^^^^^

::

    {attribute 'qualified_only'}
    VAR_GLOBAL
        nTooLow : UDINT;
        nTooHigh : UDINT;
        nDivByZero : UDINT;
    END_VAR


POUs
----


CheckBounds
^^^^^^^^^^^

::

    // Implicitly generated code : DO NOT EDIT
    FUNCTION CheckBounds : DINT
    VAR_INPUT
        index, lower, upper: DINT;
    END_VAR
    // User defined local variables
    VAR
        sMessageLow   : STRING := 'CheckBounds: Index too low (%d)';
        sMessageHigh  : STRING := 'CheckBounds: Index too high (%d)';
    END_VAR
    // Index too low
    IF index < lower THEN
        CheckBounds := lower;
        // Increase global counter
        GVL_CheckBounds.nTooLow := GVL_CheckBounds.nTooLow + 1;
        // Log message
        ADSLOGDINT(msgCtrlMask := ADSLOG_MSGTYPE_WARN,
                   msgFmtStr   := sMessageLow,
                   dintArg     := index);

    // Index too high
    ELSIF index > upper THEN
        CheckBounds := upper;
        // Increase global counter
        GVL_CheckBounds.nTooHigh := GVL_CheckBounds.nTooHigh + 1;
        // Log message
        ADSLOGDINT(msgCtrlMask := ADSLOG_MSGTYPE_WARN,
                   msgFmtStr   := sMessageHigh,
                   dintArg     := index);

    // Index OK
    ELSE
        CheckBounds := index;
    END_IF
    {flow}

    END_FUNCTION


CheckRangeSigned
^^^^^^^^^^^^^^^^

::

    // Implicitly generated code : DO NOT EDIT
    FUNCTION CheckRangeSigned : DINT
    VAR_INPUT
        value, lower, upper: DINT;
    END_VAR
    // Implicitly generated code : Only an Implementation suggestion

    IF (value < lower) THEN
        CheckRangeSigned := lower;
    ELSIF(value > upper) THEN
        CheckRangeSigned := upper;
    ELSE
        CheckRangeSigned := value;
    END_IF
    {flow}

    END_FUNCTION


CheckRangeUnsigned
^^^^^^^^^^^^^^^^^^

::

    // Implicitly generated code : DO NOT EDIT
    FUNCTION CheckRangeUnsigned : UDINT
    VAR_INPUT
        value, lower, upper: UDINT;
    END_VAR
    // Implicitly generated code : Only an Implementation suggestion
    {noflow}
    IF (value < lower) THEN
        CheckRangeUnsigned := lower;
    ELSIF(value > upper) THEN
        CheckRangeUnsigned := upper;
    ELSE
        CheckRangeUnsigned := value;
    END_IF
    {flow}

    END_FUNCTION


CurrentBPUpdate
^^^^^^^^^^^^^^^

::

    PROGRAM CurrentBPUpdate
    VAR
        {attribute 'pytmc' := '
            pv: @(PREFIX)PE
        '}
    	fbLPhotonEnergy : FB_LPhotonEnergy;
    	
    	{attribute 'pytmc' := '
            pv: @(PREFIX)L:Rate
            link: IOC:BSY0:MP01:BYKIK_RATE
            field: EGU RateEnum
        '}
        fbBYKIK_Rate : FB_LREALFromEPICS := (
    		iMaximumValidSeverity := 2);
    	
    	{attribute 'pytmc' := '
            pv: @(PREFIX)
        '}
    	fbEPICSLRate : FB_RateFromEPICS;

    	// Stoppers

        {attribute 'TcLinkTo' := '
                    .i_StopperInLS:=TIIB[PPS_Stoppers]^Channel 1^ST1L0_PPS_IN;
                    .i_StopperOutLS:=TIIB[PPS_Stoppers]^Channel 2^ST1L0_PPS_OUT;
                    .q_StopperOUT_Relay:=TIIB[MPS_Relay]^Channel 1^ST1L0_RELAY_OUT;
                    .q_StopperIN_Relay:=TIIB[MPS_Relay]^Channel 2^ST1L0_RELAY_IN;
    	'}
        st1l0Watcher : FB_LStopper(
            PMPS.L_Stopper.ST1L0,
            'ST1L0');

    END_VAR
    // Acquiring photon energy
    fbLPhotonEnergy(BP:=PMPS_GVL.stCurrentBeamParameters);



    // Acquiring L-line rate
    fbEPICSLRate(BP:=PMPS_GVL.stCurrentBeamParameters, fbBYKIK_Rate:=fbBYKIK_Rate, FFO:=GVL.g_FastFaultOutput1);


    // Watching and relaying stopper statuses
    st1l0Watcher(stCurrentBP := PMPS_GVL.stCurrentBeamParameters);

    END_PROGRAM


CXDisplay
^^^^^^^^^

::

    PROGRAM CXDisplay
    VAR
        DisplayStats : FB_CXSetTextDisplayUSB := (nPort:=28928);
        fbFormat   : FB_FormatString;
        bError     : BOOL;
        nErrID     : UDINT;
        sOut       : T_MaxString;
    END_VAR
    (*
    DisplayStats.bExecute S= NOT DisplayStats.bBusy AND NOT DisplayStats.bError;
    DisplayStats.bExecute R= DisplayStats.bBusy OR DisplayStats.bError;

    DisplayStats.sLine1 := 'PMPS-ARBITER-K';
    fbFormat(sFormat := 'Fast Faults: %d', arg1:=F_ULINT(PMPS_GVL.AccumulatedFF), sOut=>DisplayStats.sLine2, bError => bError, nErrID => nErrID );

    DisplayStats(eMode:=E_CX2100_DisplayModesWr.eCX2100_WriteLines);
    *)

    END_PROGRAM


Fast_Faults_Evaluate
^^^^^^^^^^^^^^^^^^^^

::

    PROGRAM Fast_Faults_Evaluate
    VAR
    END_VAR
    //g_FastFaultOutput1.EvaluateOutput(bAutoReset:=TRUE);
    //g_FastFaultOutput2.EvaluateOutput(bAutoReset:=TRUE);

    END_PROGRAM


MachineSimulation
^^^^^^^^^^^^^^^^^

::

    PROGRAM MachineSimulation
    VAR
        fbMachine	:	FB_MachineSimulator; //Simulates attenuator as well
        fbeVSimulator : FB_eVSimulator := (NoiseLevel := 1);
    	rTestPhotonEnergy : REAL;
    END_VAR
    // reV Simulator
    fbeVSimulator();

    // Machine simulator
    fbMachine(
        i_stAssertedParams := PMPS_GVL.stRequestedBeamParameters,
        iq_stMachineParams := PMPS_GVL.stCurrentBeamParameters,
        i_xFault	:= NOT GVL.g_FastFaultOutput1.q_xFastFaultOut,
    	xEnableAtt := TRUE,
    	xEnableRate := FALSE,
    	xEnablePE := TRUE
        );

    //PMPS_GVL.stCurrentBeamParameters.neVRange := F_eVRangeCalculator(rTestPhotonEnergy, PMPS_GVL.stCurrentBeamParameters.neVRange);
    //PMPS_GVL.stCurrentBeamParameters.neVRange := 0;

    END_PROGRAM


MAIN
^^^^

::

    PROGRAM MAIN
    VAR
        Initialize	:	BOOL := TRUE;

        fbLogHandler : FB_LogHandler;
        fbEcatDiag : FB_EcatDiagWrapper;

    	idx: UINT;
    END_VAR
    //Arbiter PLC

    IF Initialize THEN
        Initialize := FALSE;
    	
    	// Setting apertures to zero for now
    	FOR idx := 1 TO PMPS_GVL.MAX_APERTURES DO
    		PMPS_GVL.stCurrentBeamParameters.astApertures[idx].Height := 0;
    		PMPS_GVL.stCurrentBeamParameters.astApertures[idx].Width := 0;
    	END_FOR
    END_IF

    // Ethercat Diagnostics
    fbEcatDiag();

    CurrentBPUpdate();

    ///////////////////////////////////////////////////
    // This code should be disabled or removed in deployment
    // Might have a switch to change to simulation mode
    MachineSimulation();
    //Testing();
    ///////////////////////////////////////////////////

    // PMPS Functionality

    PMPS_Arbiter();



    fbLogHandler();

    END_PROGRAM
    ACTION Initialize:

    END_ACTION


PMPS_Arbiter
^^^^^^^^^^^^

::

    PROGRAM PMPS_Arbiter
    VAR

        fbBPRequestor : FB_BPRequestor; // Updates global PMPS RequestedBeamParams
        {attribute 'pytmc' := '
        pv: @(PREFIX)PhotonEnergyWatcher
        '}
        fbPhotonEnergyWatcher	:	FB_PhotonEnergyWatcher;
        {attribute 'pytmc' := '
        pv: @(PREFIX)BeamClassOutputs
        '}
        fbMPSInterface	:	FB_BeamClassOutputs;
        {attribute 'pytmc' := '
        pv: @(PREFIX)CuRateOutputs
        '}
        fbCuInterface	:	FB_CTLS_Outputs;

    	{attribute 'pytmc' := '
        	pv: @(PREFIX)BeamParamCntl
        '}
        fbBPControl : FB_BPControlDevice(nID:=10);

        (* Subsystem requests use this FB and a pragma link to pass their requests to the arbiter.
        The fb is called on each cycle and updates the arbiter with the current BP set requested
        from the subsystem PLC.*)
        //<TODO> make this so it does input and output to the IF
        (*{attribute 'pytmc' := '
        pv: @(PREFIX):PLC1
        '}*)
        {attribute 'TcLinkTo' := '.i_RequestedBP:=TIIB[plc-lfe-motion]^IO Inputs^RequestedBP;
                                    .o_CurrentBP:=TIIB[plc-lfe-motion]^IO Outputs^CurrentBP;
                                    .i_Connected:=TIIB[plc-lfe-motion]^SYNC Inputs^External device not connected;
                                    .i_WcState:=TIIB[plc-lfe-motion]^WcState^WcStateIn;
                                    .i_TxPDOState:=TIIB[plc-lfe-motion]^SYNC Inputs^TxPDO state;
                                    '}
        plc_lfe_motion_PMPS_IO : FB_ArbiterToSubSys_IO := (RequestingSystemID := 16#FF0F);
    	
    	    {attribute 'TcLinkTo' := '.i_RequestedBP:=TIIB[plc-lfe-optics]^IO Inputs^RequestedBP;
                                    .o_CurrentBP:=TIIB[plc-lfe-optics]^IO Outputs^CurrentBP;
                                    .i_Connected:=TIIB[plc-lfe-optics]^SYNC Inputs^External device not connected;
                                    .i_WcState:=TIIB[plc-lfe-optics]^WcState^WcStateIn;
                                    .i_TxPDOState:=TIIB[plc-lfe-optics]^SYNC Inputs^TxPDO state;
                                    '}
        plc_lfe_optics_PMPS_IO : FB_ArbiterToSubSys_IO := (RequestingSystemID := 16#FF10);

    	    {attribute 'TcLinkTo' := '.i_RequestedBP:=TIIB[plc-xrt-homs]^IO Inputs^RequestedBP;
                                    .o_CurrentBP:=TIIB[plc-xrt-homs]^IO Outputs^CurrentBP;
                                    .i_Connected:=TIIB[plc-xrt-homs]^SYNC Inputs^External device not connected;
                                    .i_WcState:=TIIB[plc-xrt-homs]^WcState^WcStateIn;
                                    .i_TxPDOState:=TIIB[plc-xrt-homs]^SYNC Inputs^TxPDO state;
                                    '}
        plc_xrt_homs_PMPS_IO : FB_ArbiterToSubSys_IO := (RequestingSystemID := 16#FF13);

    	
    	{attribute 'TcLinkTo' := '.i_RequestedBP:=TIIB[plc-lfe-vacuum]^IO Inputs^RequestedBP;
    								.o_CurrentBP:=TIIB[plc-lfe-vacuum]^IO Outputs^CurrentBP;
    								.i_Connected:=TIIB[plc-lfe-vacuum]^SYNC Inputs^External device not connected;
    								.i_WcState:=TIIB[plc-lfe-vacuum]^WcState^WcStateIn;
    								.i_TxPDOState:=TIIB[plc-lfe-vacuum]^SYNC Inputs^TxPDO state;
    								'}
        plc_lfe_vac_PMPS_IO : FB_ArbiterToSubSys_IO := (RequestingSystemID := 16#FF11);
    	
    		{attribute 'TcLinkTo' := '.i_RequestedBP:=TIIB[plc-lfe-gatt]^IO Inputs^RequestedBP;
    								.o_CurrentBP:=TIIB[plc-lfe-gatt]^IO Outputs^CurrentBP;
    								.i_Connected:=TIIB[plc-lfe-gatt]^SYNC Inputs^External device not connected;
    								.i_WcState:=TIIB[plc-lfe-gatt]^WcState^WcStateIn;
    								.i_TxPDOState:=TIIB[plc-lfe-gatt]^SYNC Inputs^TxPDO state;
    								'}
        plc_lfe_gatt_PMPS_IO : FB_ArbiterToSubSys_IO := (RequestingSystemID := 16#FF12);
    	
        (*{attribute 'pytmc' := '
        pv: @(PREFIX)SubSysIO:PLC2
        '}*)
        {attribute 'TcLinkTo' := '.i_RequestedBP:=TIIB[SubSysPLC2]^IO Inputs^RequestedBP;
                                    .i_xNewRequest:=TIIB[SubSysPLC2]^IO Inputs^xNewRequest;
                                    .o_CurrentBP:=TIIB[SubSysPLC2]^IO Outputs^CurrentBP;
                                    .i_Connected:=TIIB[SubSysPLC2]^SYNC Inputs^External device not connected;
                                    .i_WcState:=TIIB[SubSysPLC2]^WcState^WcState;
                                    .i_TxPDOState:=TIIB[SubSysPLC2]^SYNC Inputs^TxPDO state;
                                    .i_TxPDOToggle:=TIIB[SubSysPLC2]^SYNC Inputs^TxPDO toggle;
                                    '}
        //fbSubSys2_PMPS_IO : FB_ArbiterToSubSys_IO := (RequestingSystemID := 16#FF10);



    	fbSetPE	:	PE_Ranges;
    	
    	// plc-xrt-homs Fast Fault Link
    	    {attribute 'TcLinkTo' := 'TIIB[plc-xrt-homs]^IO Inputs^FFO1'}
    	i_bFastFaultOutput_plc_xrt_homs AT %I* : BOOL;
    	
    	ffPLC_XRT_HOMS : FB_FastFault := (
    		i_DevName := 'plc-xrt-homs FFO1',
    		i_Desc := 'Fast fault output link',
    		i_TypeCode := 16#C,
    		i_xAutoReset := TRUE);

    END_VAR
    ////////////////////////////////////////////////////////////

    // Dummy device for controling pmps beam parameters
    fbBPControl(Arbiter:=g_fbArbiter1);

    // Updating arbiter with subsystem requests.
    plc_lfe_motion_PMPS_IO(Arbiter:=GVL.g_fbArbiter1, fbFFHWO:=GVL.g_FastFaultOutput1, Reset:=GVL.AttemptReset);
    plc_lfe_optics_PMPS_IO(Arbiter:=GVL.g_fbArbiter1, fbFFHWO:=GVL.g_FastFaultOutput1, Reset:=GVL.AttemptReset);
    plc_lfe_vac_PMPS_IO(Arbiter:=GVL.g_fbArbiter1, fbFFHWO:=GVL.g_FastFaultOutput1, Reset:=GVL.AttemptReset);
    plc_lfe_gatt_PMPS_IO(Arbiter:=GVL.g_fbArbiter1, fbFFHWO:=GVL.g_FastFaultOutput1, Reset:=GVL.AttemptReset);
    plc_xrt_homs_PMPS_IO(Arbiter:=GVL.g_fbArbiter1, fbFFHWO:=GVL.g_FastFaultOutput1, Reset:=GVL.AttemptReset);

    //Overriding the preemptive requests from the optics systems until they are valid
    //GVL.g_fbArbiter1.RemoveRequest(nReqId:=plc_lfe_optics_PMPS_IO.RequestingSystemID);

    // Beam parameter requestor
    fbBPRequestor(Arbiter:=GVL.g_fbArbiter1, q_ReqBP => PMPS_GVL.stRequestedBeamParameters);

    // Request beam class
    fbMPSInterface(BP := PMPS_GVL.stRequestedBeamParameters);

    // Request Cu beam rate
    fbCuInterface(BP := PMPS_GVL.stRequestedBeamParameters);


    // Keep an eye on the photon energy
    fbPhotonEnergyWatcher(i_stCurrentBeamParams	:= PMPS_GVL.stCurrentBeamParameters,
                        i_stRequestedBeamParams := PMPS_GVL.stRequestedBeamParameters,
                        io_fbFFHWO:= GVL.g_FastFaultOutput1,
                        i_xReset := GVL.AttemptReset);

    // FFO from plc-xrt-homs
    ffPLC_XRT_HOMS(i_xOK := i_bFastFaultOutput_plc_xrt_homs,
    	io_fbFFHWO := g_FastFaultOutput1);

    // FF
    g_FastFaultOutput1.Execute();
    g_FastFaultOutput2.Execute();

    END_PROGRAM


Testing
^^^^^^^

::

    PROGRAM Testing
    VAR
        AttemptReset : TON := (PT:=T#1s);
        gAttemptReset : TON := (PT:=T#500ms);

        testFF : FB_FastFault;
        cycle : INT;
    END_VAR
    // Trip a fast fault periodically
    testFF(io_fbFFHWO:= g_FastFaultOutput1);
    //testFF.i_xOK := (cycle mod 1000) = 0;
    //cycle := cycle + 1;

    //Periodically try to reset the photon energy fault.
    AttemptReset(IN:=PMPS_Arbiter.fbPhotonEnergyWatcher.xPhotonEnergyWithinBounds, Q=>GVL.AttemptReset);

    gAttemptReset(IN:=GVL.g_FastFaultOutput1.xOK, Q=>GVL.g_FastFaultOutput1.i_xReset);

    END_PROGRAM

